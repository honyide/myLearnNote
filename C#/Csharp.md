# C# Note

# question

**元组**

**临时虚拟变量**

**ref关键字和out关键字**

**协变和抗变**

**数组和指针，不安全代码**

**string builder**





## 概述

### 对象的内容

属性和字段

属性不提供对数据的直接访问，通常在访问状态的情况最好提供属性，方便控制各种行为

对属性读写的访问   可访问性   变量作用域

只读字段和常量的差别，可变字段？

方法

### 数据类型

#### question

预定义类型

类型转换，溢出检查，check关键字

可空类型？



#### const常量

 const常量不能被修改，且必须在被声明时初始化。

const不能与static一起使用，常量默认是static的

#### readonly修饰只读字段

使用readonly来修饰只读字段

只读字段可以在 声明时或者构造函数中初始化

可以和static一起使用，声明静态只读字段

静态只读字段可以在声明或静态构造函数中初始化

### 对象的生命周期

构造阶段

析构阶段

构造函数

this关键字和base关键字

构造函数执行序列、构造函数初始化器

析构函数

### 静态成员和实例类成员

静态成员的作用 有哪些静态成员 使用静态成员的好处

静态构造函数

静态类

静态类的所有成员都必须是静态的

静态类不能实例化

静态字段只有一个副本

static可以修饰方法、字段、属性、事件，且访问被static修饰的静态成员只能通过类名访问





## 面向对象

### 接口

接口和抽象类的区别

接口可以有普通方法，不能有数据成员

接口只能包含属性索引方法和事件的声明，不能提供任何成员的实现

接口是什么  使用有哪些限制  有什么优点 什么时候使用

UML如何表示  设计模式的封闭原则

可删除对象

### 继承

一个类型派生自一个基类型，则它拥有基类型的所有成员字段和函数，且派生类型采用基类型的每个函数的实现代码

##### this&&base关键字

this关键字和base关键字用于区分子类成员和继承的基类成员

this引用当前类的成员，base则引用基类的成员



##### 虚方法和隐藏方法

当基类和派生类有同名方法时，我们通常采用两种方法：

1.在父类定义虚方法之后在子类中重写，

2.在派生类中隐藏基类方法



##### 抽象类和密封类

抽象类中特有一种抽象方法，抽象方法是没有函数体的

抽象类不能被实例化

抽象类的子类必须实现继承的函数

###### 密封类和密封方法

与抽象类相对的（抽象类必须被继承），密封类不能被继承。

同样的，sealed修饰重写过的方法，且该方法不能再次被重写



##### 在继承中，子类的构造函数

在实例化派生类之前，必须先实例化它的基类

通常我们在初始化一个类时会先默认调用父类中的构造函数（无参数），然后再调用子类的构造函数。

我们也可以配合使用base和this关键字来控制构造函数的执行过程

```

```







继承的UML表示

继承父类后成员的可访问性？什么是抽象类？使用抽象类有哪些要求？

什么是密封类、密封类的特点是？

c#中所有对象的共同基类是Object

### 多态性

什么是多态？

使用多态需要注意？

如何使用接口的多态性？

### 对象间的关系

包含关系

集合关系

### 运算符重载

### 引用类型和值类型

装箱和拆箱











### 堆栈和静态存储区

程序所有的数据，都是存储在内存中的

栈空间比较小，读取速度快，数据采用后进先出的原则

堆空间比较大，读取速度慢，堆里的内存以任意顺序存入和移除

值变量存储在栈中，引用变量部分存储在栈中，部分存储在堆中，静态存储区则存储字符串 

  

## 集合比较和和转化

### 集合类

在c#中，数组为 System.Array 类的实例，它是集合类中的一种类型。

集合类一般用于处理对象列表，功能比简单数组要多，其功能一般是通过实现System.Colletions 名称空间的接口来获得。

System.Colletions 空间的几个接口提供了基本的集合功能：

IEnumerable:可迭代集合中的项

 ICollection：（继承于IEnumerable）可以获取集合中项的个数，并能把项复制到一个简单的数组类型中。

IList：（继承于IEnumerable和ICollection）提供了集合的项列表，允许访问这些项，并提供其他一些与项列表相关的基本功能。

IDictionary（继承于IEnumerable和ICollection）类似于IList，但提供了可通过键值（而不是索引）访问的项列表。

##### ArrayList

System.Collections.ArrayList也实现了IList、ICollection和IEnumerable接口，但实现方式比System.Array更复杂。

###### ArrayList  的几个特性

1. ArrayList不需要初始化大小

2. ArrayList的count属性对标Array的Length属性

3. ArrayList 有两个构造函数

   （1）把一个现有的集合作为参数，把内容复制到新实例中

   （2）设置一个暂时的容量，来指定集合中可包含的基础项数，当项数超过这个值时容量会自动增加一倍

4. ArrayList 没有现成的，或null引用的项，需要通过add方法来添加新项

5. ArrayList 有更多的功能，比如 Remove(),RemoveAt(),AddRange()等等

6. ArrayList是System.Object对象的集合，调用方法时必须对所有的项进行数据转换

7. ArrayList有几个专用的方法：AddRange（），InsertRange（）





##### 如何创建自己的强类型化的集合

我们可以从一个类中派生自己的集合，例如System.Collections.CollectionBase类，这个抽象类提供了集合类的大量实现代码

###### 定制集合类的好处：

1.我们可以把集合类定制为强类型化的（从集合中提取项时，不需要类型转换）

2.我们可以提供专用的方法







## 泛型

动态类型dynamic







## 事件和委托

### 委托

委托是一种存储函数应用的类型。使用delegate关键字，指定一个返回类型和参数列表

定义委托之后就可以声明该委托的变量，接着就可以把该变量初始化为与委托具有相同返回类型和参数列表的函数引用。

这样就能用委托调用该函数

我们可以通过把函数委托传递给函数来控制函数的执行（就像选择使用的插件一样）

### 事件

事件类似于异常，它们都由对象引发（抛出），

我们可以提供一些代码来**订阅**事件，在事件发生时会执行这些代码。

（注：事件处理方法必须匹配事件所要求的返回类型，这个限制是事件定义的一部分，由一个委托指定）

单个事件可以提供多个处理程序（订阅），在事件发生时这些程序都会调用。

**委托是一个存储函数引用的容器，事件则确定什么时候使用委托**



#### 定义事件



定义事件之前必须先定义一个委托类型，这个委托类型指定了事件处理方法必须拥有的返回类型和参数。

使用event关键字，并指定委托类型来声明事件，之后就可以通过事件名称来直接调用了。



##### 多用途的事件处理程序

参考 Timer.Elapsed 的事件委托参数(object 引发事件对象的引用 和 ElaspedEventArgs 由事件传送的参数)



发送一个引发事件对象的引用，将其作为事件处理程序的一个参数，就可以为不同对象定制程序的响应。用该引用可以访问源对象及其属性

发送包含在派生于 System.EventArgs (与 ElapsedEventArgs 相同)的类中的参数，就可以将其他必要信息提供作为参数



这里使用object的原因是，我们有时需要为不同对象引发的同一事件使用同一个事件处理程序，但我们仍要指定是哪个对象生成了事件

##### EventHandler 和泛型EventHandler <T>类型

因为大多数的情况都需要多用途的事件处理程序，所以.NET提供了两个委托类型EventHandler 和泛型EventHandler，以便定义事件。

如果事件不需要事件实参数据，也可以使用 EventHandler 委托类型，但需要传递 EventArgs.Empty 作为实参值。



##### 返回值和事件处理程序

我们可以选择给事件提供返回类型，但可能会出现问题：引发事件后，可能会调用多个事件处理程序，那我们将不知道该使用哪个值？

系统是这样处理这个问题的：只访问事件处理程序最后返回的那个值，也就是最后一个订阅该事件处理程序返回的值

我们最好令返回类型为void，并避免out类型参数的使用



### 匿名方法

匿名方法并不是某个类上的方法，而纯粹为用作委托而创造

匿名方法的使用

```
delegate (parameters){
//Anonymous method code.
};
```

parameters是用于匹配委托类型的参数列表

**注意：**

对于包含匿名函数的代码块来说，他们是局部的，可以访问这个作用域的局部变量。但是如果该函数使用了局部变量，那这个变量就会变成外部变量。这个变量只有等使用它们的匿名方法销毁时才会删除。如果外部变量占用大量内存，就可能导致性能问题



##### 委托中的匿名方法

###### 回顾一下给事件添加处理程序的过程

1.定义事件处理方法

2.声明一个委托变量

3.把委托变量初始化为委托类型的实例，该实例指向事件处理方法

4.把委托添加到事件的订阅者列表中



我们可以把过程做的简单些，因为一般不使用变量来存储委托，只在订阅事件的时候使用委托的实例

```

这里添加一个实例
```



我们甚至可以通过C#的方法组语法来进一步简化

```
另一个实例
```

C#编译器知道 Elasped 事件需要的委托类型，所以可以填充该类型，**但是大多数情况下都不推荐这么做，这会使代码很难理解，也不清楚会发生什么**

我们可以使用匿名方法来进行简化

```
实例
```

这段代码和单独使用事件处理程序的区别在于，匿名方法对其余代码而言是隐藏的，如：不能在程序的其他地方重用这个事件处理程序。

**delegate关键字有时候会带来混淆：它有双重含义：匿名方法和定义委托**



##### 把Lambda表达式用于匿名方法

Lambda表达式由以下三个部分组成：括号中的 参数列表（未类型化）、=>运算符 、 C#语句

编译器会从上下文中推断出参数的类型，=>用于分隔参数列表和表达式体

编译器提取Lambda表达式时，会创建一个匿名方法，其工作方式和我们直接声明匿名方法相同。

######  Lambda表达式的参数

Lambda表达式可以使用类型推理功能来确定传递的参数类型，也可以定义类型

显式的参数类型便于理解，但不够简明灵活

注意：不能在一个Lambda表达式里同时使用显式和隐式的参数类型

如果只有一个隐式类型的参数，就可以省略参数列表的括号，可以用空括号表示无参数的Lambda表达式

###### Lambda表达式的语句体

Lambda表达式的语句体可以包含多个语句（只需要把它们放在花括号中）

如果使用Lambda表达式且返回类型不是void的委托类型，就需要用return返回一个值

###### Lambda表达式用作委托和表达式树

可以用两种方式来解释Lambda表达式：

1.把Lambda表达式是一个委托，可以赋值给委托变量

一般我们会把至多有八个参数的Lambda表达式表示为System名称空间里定义的几个泛型类型：

Action , Action<> ,  Func  < >

在很多情况下，我们都使用上面的泛型委托类型，而不必定义自己的泛型委托类型

2.可以把Lambda表达式解释为表达式树

结合LINQ功能来学习



## 文件

### 用于输入和输出的类

文件类包含在 System.IO名称空间中，在C#应用程序中引用此名称空间后，就能访问用于在文件中读写数据的类，而不必完全限定类型名

引用System.IO.Compression名称空间后就允许读取压缩文件



## XML和JSON

XML和JSON都是数据语言，以简单的文本格式存储数据

### XML基础

XML（可扩展标记语言），将数据以一种简单的文本格式存储，它是一种W3C标准格式，类似于HTML

XML的基本格式很简单

```
举例
```

### JSON基础

JSON表示 JavaScript Object Notation，和XML一样，它也是一个标准。

JSON是传输Web服务和Web浏览器中数据的一种常见格式

JSON也有一个简单的格式

```
举例
```

JSON 用（{}）分隔数据块，用（[]）界定数组

JSON比XML更紧凑，但人们更难以阅读

### XML模式

XML文档可以用模式来描述，模式是另外一个XML文件，描述了允许在一个特定的文档中使用的元素和特性。

可以根据模式验证XML文档，确保程序不会遇到不打算处理的数据。用于C#的标准XML格式是XSD

```
举例
```



### XML文档对象模型（DOM）

#### 常用操作ＸＭＬ类

　ＸｍｌＤｏｃｕｍｅｎｔ类：用于读取XML文件，该类位于Ｓｙｓｔｅｍ．Ｘｍｌ名称空间中

　ＸｍｌＥｌｅｍｅｎｔ类：用于访问文档中的信息

##### 修改节点的值

插入、删除、选择

#### 用ＸＰａｔｈ搜索XML

ＸＰａｔｈ是ＸＭＬ文档的查询语言，就像ｓｑｌ是关系数据库的查询语言一样



##### JSON序列化与反序列化



## 反射和特性

### 反射

我们通常使用Type类来反射数据，常用的方法有

Type是抽象类，不能实例化，被设计用来包含类型的特性。使用这个类的对象能让 我们获取程序使用的类型的信息。

对于程序中用到的每一个类型，CLR都会创建一个包含这个类型信息的Type类型的 对象。 程序中用到的每一个类型都会关联到独立的Type类的对象。 不管创建的类型有多少个示例，只有一个Type对象会关联到所有这些实例。

#### 获取Type对象

 获取Type对象有两种方式

1，Type t = myInstance.GetType();//通过类的实例来获取Type对象 在object类有一个GetType的方法，返回Type对象，因为所有类都是从 object继承的，所以我们可以在任何类型上使用GetType（）来获取它的Type对象 

2，Type t = typeof(ClassName);//直接通过typeof运算符和类名获取Type对象

#### 特性

 Obsolete特性

 Conditional特性

DebuggerStepThrough特性

多个特性 

我们可以为单个结构应用多个特性。有下面两种添加方式 独立的特性片段相互叠在一起  [Serializable]  [MyAttribute("Simple class","Version 3.57")] 单个特性片段，特性之间使用逗号间隔  [Serializable,MyAttribute("Simple class","Version 3.57")]













## LINQ

LINQ是Ｃ＃的一个扩展，可以将数据查询语言直接集成到编程语言当中



##### 什么时候，我们喜欢用linq语句



### LINQ查询语法

大多数使用linq方法都要求传送一个方法或函数，来计算查询表达式。方法/函数参数以委托的形式传送，一般引用一个匿名方法。

使用Lambda表达式可以很容易地创建在linq查询中使用的方法。

```

```

#### 排序查询结果

用where子句（或者Where（）方法调用）找到了感兴趣的数据后，linq可以方便得对得到的数据进行进一步的处理，如重新排列结果顺序。

##### orderby子句























